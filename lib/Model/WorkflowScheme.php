<?php
/**
 * WorkflowScheme
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * The Jira Cloud platform REST API
 *
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT
 * Contact: ecosystem@atlassian.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * WorkflowScheme Class Doc Comment
 *
 * @category Class
 * @description Details about a workflow scheme.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class WorkflowScheme implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'WorkflowScheme';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'default_workflow' => 'string',
        'description' => 'string',
        'draft' => 'bool',
        'id' => 'int',
        'issue_type_mappings' => 'array<string,string>',
        'issue_types' => 'array<string,\OpenAPI\Client\Model\IssueTypeDetails>',
        'last_modified' => 'string',
        'last_modified_user' => '\OpenAPI\Client\Model\WorkflowSchemeLastModifiedUser',
        'name' => 'string',
        'original_default_workflow' => 'string',
        'original_issue_type_mappings' => 'array<string,string>',
        'self' => 'string',
        'update_draft_if_needed' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'default_workflow' => null,
        'description' => null,
        'draft' => null,
        'id' => 'int64',
        'issue_type_mappings' => null,
        'issue_types' => null,
        'last_modified' => null,
        'last_modified_user' => null,
        'name' => null,
        'original_default_workflow' => null,
        'original_issue_type_mappings' => null,
        'self' => 'uri',
        'update_draft_if_needed' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'default_workflow' => false,
		'description' => false,
		'draft' => false,
		'id' => false,
		'issue_type_mappings' => false,
		'issue_types' => false,
		'last_modified' => false,
		'last_modified_user' => false,
		'name' => false,
		'original_default_workflow' => false,
		'original_issue_type_mappings' => false,
		'self' => false,
		'update_draft_if_needed' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'default_workflow' => 'defaultWorkflow',
        'description' => 'description',
        'draft' => 'draft',
        'id' => 'id',
        'issue_type_mappings' => 'issueTypeMappings',
        'issue_types' => 'issueTypes',
        'last_modified' => 'lastModified',
        'last_modified_user' => 'lastModifiedUser',
        'name' => 'name',
        'original_default_workflow' => 'originalDefaultWorkflow',
        'original_issue_type_mappings' => 'originalIssueTypeMappings',
        'self' => 'self',
        'update_draft_if_needed' => 'updateDraftIfNeeded'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'default_workflow' => 'setDefaultWorkflow',
        'description' => 'setDescription',
        'draft' => 'setDraft',
        'id' => 'setId',
        'issue_type_mappings' => 'setIssueTypeMappings',
        'issue_types' => 'setIssueTypes',
        'last_modified' => 'setLastModified',
        'last_modified_user' => 'setLastModifiedUser',
        'name' => 'setName',
        'original_default_workflow' => 'setOriginalDefaultWorkflow',
        'original_issue_type_mappings' => 'setOriginalIssueTypeMappings',
        'self' => 'setSelf',
        'update_draft_if_needed' => 'setUpdateDraftIfNeeded'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'default_workflow' => 'getDefaultWorkflow',
        'description' => 'getDescription',
        'draft' => 'getDraft',
        'id' => 'getId',
        'issue_type_mappings' => 'getIssueTypeMappings',
        'issue_types' => 'getIssueTypes',
        'last_modified' => 'getLastModified',
        'last_modified_user' => 'getLastModifiedUser',
        'name' => 'getName',
        'original_default_workflow' => 'getOriginalDefaultWorkflow',
        'original_issue_type_mappings' => 'getOriginalIssueTypeMappings',
        'self' => 'getSelf',
        'update_draft_if_needed' => 'getUpdateDraftIfNeeded'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('default_workflow', $data ?? [], null);
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('draft', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('issue_type_mappings', $data ?? [], null);
        $this->setIfExists('issue_types', $data ?? [], null);
        $this->setIfExists('last_modified', $data ?? [], null);
        $this->setIfExists('last_modified_user', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('original_default_workflow', $data ?? [], null);
        $this->setIfExists('original_issue_type_mappings', $data ?? [], null);
        $this->setIfExists('self', $data ?? [], null);
        $this->setIfExists('update_draft_if_needed', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets default_workflow
     *
     * @return string|null
     */
    public function getDefaultWorkflow()
    {
        return $this->container['default_workflow'];
    }

    /**
     * Sets default_workflow
     *
     * @param string|null $default_workflow The name of the default workflow for the workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. If `defaultWorkflow` is not specified when creating a workflow scheme, it is set to *Jira Workflow (jira)*.
     *
     * @return self
     */
    public function setDefaultWorkflow($default_workflow)
    {

        if (is_null($default_workflow)) {
            throw new \InvalidArgumentException('non-nullable default_workflow cannot be null');
        }

        $this->container['default_workflow'] = $default_workflow;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description The description of the workflow scheme.
     *
     * @return self
     */
    public function setDescription($description)
    {

        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }

        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets draft
     *
     * @return bool|null
     */
    public function getDraft()
    {
        return $this->container['draft'];
    }

    /**
     * Sets draft
     *
     * @param bool|null $draft Whether the workflow scheme is a draft or not.
     *
     * @return self
     */
    public function setDraft($draft)
    {

        if (is_null($draft)) {
            throw new \InvalidArgumentException('non-nullable draft cannot be null');
        }

        $this->container['draft'] = $draft;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id The ID of the workflow scheme.
     *
     * @return self
     */
    public function setId($id)
    {

        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets issue_type_mappings
     *
     * @return array<string,string>|null
     */
    public function getIssueTypeMappings()
    {
        return $this->container['issue_type_mappings'];
    }

    /**
     * Sets issue_type_mappings
     *
     * @param array<string,string>|null $issue_type_mappings The issue type to workflow mappings, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.
     *
     * @return self
     */
    public function setIssueTypeMappings($issue_type_mappings)
    {

        if (is_null($issue_type_mappings)) {
            throw new \InvalidArgumentException('non-nullable issue_type_mappings cannot be null');
        }

        $this->container['issue_type_mappings'] = $issue_type_mappings;

        return $this;
    }

    /**
     * Gets issue_types
     *
     * @return array<string,\OpenAPI\Client\Model\IssueTypeDetails>|null
     */
    public function getIssueTypes()
    {
        return $this->container['issue_types'];
    }

    /**
     * Sets issue_types
     *
     * @param array<string,\OpenAPI\Client\Model\IssueTypeDetails>|null $issue_types The issue types available in Jira.
     *
     * @return self
     */
    public function setIssueTypes($issue_types)
    {

        if (is_null($issue_types)) {
            throw new \InvalidArgumentException('non-nullable issue_types cannot be null');
        }

        $this->container['issue_types'] = $issue_types;

        return $this;
    }

    /**
     * Gets last_modified
     *
     * @return string|null
     */
    public function getLastModified()
    {
        return $this->container['last_modified'];
    }

    /**
     * Sets last_modified
     *
     * @param string|null $last_modified The date-time that the draft workflow scheme was last modified. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows.
     *
     * @return self
     */
    public function setLastModified($last_modified)
    {

        if (is_null($last_modified)) {
            throw new \InvalidArgumentException('non-nullable last_modified cannot be null');
        }

        $this->container['last_modified'] = $last_modified;

        return $this;
    }

    /**
     * Gets last_modified_user
     *
     * @return \OpenAPI\Client\Model\WorkflowSchemeLastModifiedUser|null
     */
    public function getLastModifiedUser()
    {
        return $this->container['last_modified_user'];
    }

    /**
     * Sets last_modified_user
     *
     * @param \OpenAPI\Client\Model\WorkflowSchemeLastModifiedUser|null $last_modified_user last_modified_user
     *
     * @return self
     */
    public function setLastModifiedUser($last_modified_user)
    {

        if (is_null($last_modified_user)) {
            throw new \InvalidArgumentException('non-nullable last_modified_user cannot be null');
        }

        $this->container['last_modified_user'] = $last_modified_user;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name The name of the workflow scheme. The name must be unique. The maximum length is 255 characters. Required when creating a workflow scheme.
     *
     * @return self
     */
    public function setName($name)
    {

        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets original_default_workflow
     *
     * @return string|null
     */
    public function getOriginalDefaultWorkflow()
    {
        return $this->container['original_default_workflow'];
    }

    /**
     * Sets original_default_workflow
     *
     * @param string|null $original_default_workflow For draft workflow schemes, this property is the name of the default workflow for the original workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira.
     *
     * @return self
     */
    public function setOriginalDefaultWorkflow($original_default_workflow)
    {

        if (is_null($original_default_workflow)) {
            throw new \InvalidArgumentException('non-nullable original_default_workflow cannot be null');
        }

        $this->container['original_default_workflow'] = $original_default_workflow;

        return $this;
    }

    /**
     * Gets original_issue_type_mappings
     *
     * @return array<string,string>|null
     */
    public function getOriginalIssueTypeMappings()
    {
        return $this->container['original_issue_type_mappings'];
    }

    /**
     * Sets original_issue_type_mappings
     *
     * @param array<string,string>|null $original_issue_type_mappings For draft workflow schemes, this property is the issue type to workflow mappings for the original workflow scheme, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.
     *
     * @return self
     */
    public function setOriginalIssueTypeMappings($original_issue_type_mappings)
    {

        if (is_null($original_issue_type_mappings)) {
            throw new \InvalidArgumentException('non-nullable original_issue_type_mappings cannot be null');
        }

        $this->container['original_issue_type_mappings'] = $original_issue_type_mappings;

        return $this;
    }

    /**
     * Gets self
     *
     * @return string|null
     */
    public function getSelf()
    {
        return $this->container['self'];
    }

    /**
     * Sets self
     *
     * @param string|null $self self
     *
     * @return self
     */
    public function setSelf($self)
    {

        if (is_null($self)) {
            throw new \InvalidArgumentException('non-nullable self cannot be null');
        }

        $this->container['self'] = $self;

        return $this;
    }

    /**
     * Gets update_draft_if_needed
     *
     * @return bool|null
     */
    public function getUpdateDraftIfNeeded()
    {
        return $this->container['update_draft_if_needed'];
    }

    /**
     * Sets update_draft_if_needed
     *
     * @param bool|null $update_draft_if_needed Whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:   *  Update an active workflow scheme with `updateDraftIfNeeded` set to `true`: If a draft workflow scheme exists, it is updated. Otherwise, a draft workflow scheme is created.  *  Update an active workflow scheme with `updateDraftIfNeeded` set to `false`: An error is returned, as active workflow schemes cannot be updated.  *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to `true`: The workflow scheme is updated, as inactive workflow schemes do not require drafts to update.  Defaults to `false`.
     *
     * @return self
     */
    public function setUpdateDraftIfNeeded($update_draft_if_needed)
    {

        if (is_null($update_draft_if_needed)) {
            throw new \InvalidArgumentException('non-nullable update_draft_if_needed cannot be null');
        }

        $this->container['update_draft_if_needed'] = $update_draft_if_needed;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


